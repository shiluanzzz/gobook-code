/*
代码所在章节：4.4.3节
*/

//iface_bench_test.go
package main

import (
	//	"math/rand"
	//	"runtime"
	"testing"
)

type identifier interface {
	idInline() int32
	idNoInline() int32
}

type id32 struct{ id int32 }

// NOTE: Use pointer receivers so we don't measure the extra overhead incurred by
// autogenerated wrappers as part of our results.

func (id *id32) idInline() int32 { return id.id }

//go:noinline
func (id *id32) idNoInline() int32 { return id.id }

var escapeMePlease *id32

// escapeToHeap makes sure that `id` escapes to the heap.

//go:noinline
func escapeToHeap(id *id32) identifier {
	escapeMePlease = id
	return escapeMePlease
}

func BenchmarkMethodCall_direct(b *testing.B) { // {{{
	var myID int32

	b.Run("single/noinline", func(b *testing.B) {
		m := escapeToHeap(&id32{id: 6754}).(*id32)
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			// CALL "".(*id32).idNoInline(SB)
			// MOVL 8(SP), AX
			// MOVQ "".&myID+40(SP), CX
			// MOVL AX, (CX)
			myID = m.idNoInline()
		}
	})
	b.Run("single/inline", func(b *testing.B) {
		m := escapeToHeap(&id32{id: 6754}).(*id32)
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			// MOVL (DX), SI
			// MOVL SI, (CX)
			myID = m.idInline()
		}
	})
} // }}}

func BenchmarkMethodCall_interface(b *testing.B) { // {{{
	var myID int32

	b.Run("single/noinline", func(b *testing.B) {
		m := escapeToHeap(&id32{id: 6754})
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			// MOVQ 32(AX), CX
			// MOVQ "".m.data+40(SP), DX
			// MOVQ DX, (SP)
			// CALL CX
			// MOVL 8(SP), AX
			// MOVQ "".&myID+48(SP), CX
			// MOVL AX, (CX)
			myID = m.idNoInline()
		}
	})
	b.Run("single/inline", func(b *testing.B) {
		m := escapeToHeap(&id32{id: 6754})
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			// MOVQ 24(AX), CX
			// MOVQ "".m.data+40(SP), DX
			// MOVQ DX, (SP)
			// CALL CX
			// MOVL 8(SP), AX
			// MOVQ "".&myID+48(SP), CX
			// MOVL AX, (CX)
			myID = m.idInline()
		}
	})

} // }}}

func main() {}
